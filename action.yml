name: 'Auto-Merge Dependabot PRs'
description: 'Automatically merge Dependabot PRs based on configuration rules'
author: 'ioBroker Bot Organization'

branding:
  icon: 'git-merge'
  color: 'green'

inputs:
  github-token:
    description: 'GitHub token with permissions to merge PRs'
    required: true
  
  config-file-path:
    description: 'Path to the auto-merge configuration file'
    required: false
    default: '.github/auto-merge.yml'
  
  merge-method:
    description: 'Merge method to use (merge, squash, or rebase)'
    required: false
    default: 'merge'
  
  wait-for-checks:
    description: 'Wait for other checks to complete before merging'
    required: false
    default: 'true'
  
  max-wait-time:
    description: 'Maximum time to wait for checks in seconds'
    required: false
    default: '3600'

outputs:
  should-merge:
    description: 'Whether the PR should be merged based on configuration'
    value: ${{ steps.should-merge.outputs.should_merge }}
  
  match-reason:
    description: 'Reason for the merge decision'
    value: ${{ steps.should-merge.outputs.match_reason }}
  
  checks-passed:
    description: 'Whether all CI checks passed'
    value: ${{ steps.wait-for-checks.outputs.checks_passed || steps.skip-checks.outputs.checks_passed }}

runs:
  using: 'composite'
  steps:
    - name: Fetch Dependabot metadata
      id: dependabot-metadata
      uses: dependabot/fetch-metadata@v2
      with:
        github-token: ${{ inputs.github-token }}
    
    - name: Extract metadata for decision making
      id: metadata
      shell: bash
      env:
        GITHUB_TOKEN: ${{ inputs.github-token }}
      run: |
        # Extract update type from dependabot metadata
        # Format: "version-update:semver-patch", "version-update:semver-minor", "version-update:semver-major"
        UPDATE_TYPE_RAW="${{ steps.dependabot-metadata.outputs.update-type }}"
        
        if [[ "$UPDATE_TYPE_RAW" == *"semver-patch"* ]]; then
          UPDATE_TYPE="patch"
        elif [[ "$UPDATE_TYPE_RAW" == *"semver-minor"* ]]; then
          UPDATE_TYPE="minor"
        elif [[ "$UPDATE_TYPE_RAW" == *"semver-major"* ]]; then
          UPDATE_TYPE="major"
        else
          UPDATE_TYPE="unknown"
        fi
        
        echo "update_type=$UPDATE_TYPE" >> $GITHUB_OUTPUT
        echo "Update type: $UPDATE_TYPE"
        
        # Extract dependency type
        # Format: "direct:production" or "direct:development"
        DEPENDENCY_TYPE_RAW="${{ steps.dependabot-metadata.outputs.dependency-type }}"
        
        if [[ "$DEPENDENCY_TYPE_RAW" == *"production"* ]]; then
          DEPENDENCY_TYPE="production"
        elif [[ "$DEPENDENCY_TYPE_RAW" == *"development"* ]]; then
          DEPENDENCY_TYPE="development"
        else
          DEPENDENCY_TYPE="unknown"
        fi
        
        # Check if only package-lock.json is changed when dependency_type is unknown
        if [[ "$DEPENDENCY_TYPE" == "unknown" ]]; then
          echo "Dependency type is unknown, checking if only package-lock.json is changed..."
          
          # Get the list of changed files in the PR
          CHANGED_FILES=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files" \
            --jq '.[].filename')
          
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check if we have files and if there's exactly one
          if [[ -n "$CHANGED_FILES" ]]; then
            # Count lines (each filename is on a separate line)
            FILE_COUNT=$(echo "$CHANGED_FILES" | wc -l)
            
            # Check if only one file is changed
            if [[ $FILE_COUNT -eq 1 ]]; then
              # Trim whitespace from the single filename
              SINGLE_FILE=$(echo "$CHANGED_FILES" | xargs)
              
              # Check if it's package-lock.json
              if [[ "$SINGLE_FILE" == "package-lock.json" ]]; then
                echo "Only package-lock.json is changed, setting dependency_type to 'package-lock'"
                DEPENDENCY_TYPE="package-lock"
              fi
            fi
          fi
        fi
        
        echo "dependency_type=$DEPENDENCY_TYPE" >> $GITHUB_OUTPUT
        echo "Dependency type: $DEPENDENCY_TYPE"
        
        # Log package information
        echo "Package name(s): ${{ steps.dependabot-metadata.outputs.dependency-names }}"
        echo "Previous version: ${{ steps.dependabot-metadata.outputs.previous-version }}"
        echo "New version: ${{ steps.dependabot-metadata.outputs.new-version }}"
    
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.pull_request.base.ref }}
    
    - name: Read and parse auto-merge configuration
      id: read-config
      shell: bash
      run: |
        CONFIG_FILE="${{ inputs.config-file-path }}"
        
        if [ ! -f "$CONFIG_FILE" ]; then
          echo "Configuration file $CONFIG_FILE not found"
          echo "Using default rules:"
          echo "- Patch updates: always merge"
          echo "- Minor updates: only for devDependencies"
          echo "- Major updates: never merge"
          echo "config_exists=false" >> $GITHUB_OUTPUT
          echo "config_json=[]" >> $GITHUB_OUTPUT
        else
          echo "Configuration file found"
          echo "config_exists=true" >> $GITHUB_OUTPUT
          cat "$CONFIG_FILE"
          
          # Convert YAML to JSON for easier parsing (compact, single line)
          # Note: python3 and PyYAML are available by default on ubuntu-latest runners
          if ! CONFIG_JSON=$(python3 -c "import yaml, json, sys; print(json.dumps(yaml.safe_load(open(sys.argv[1]))))" "$CONFIG_FILE" 2>&1); then
            echo "Error: Failed to parse YAML configuration file"
            echo "Error details: $CONFIG_JSON"
            echo "config_exists=false" >> $GITHUB_OUTPUT
            echo "config_json=[]" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "config_json=$CONFIG_JSON" >> $GITHUB_OUTPUT
        fi
    
    - name: Decide if should auto-merge
      id: should-merge
      env:
        CONFIG_JSON: ${{ steps.read-config.outputs.config_json }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const updateType = '${{ steps.metadata.outputs.update_type }}';
          const dependencyType = '${{ steps.metadata.outputs.dependency_type }}';
          const configExists = '${{ steps.read-config.outputs.config_exists }}' === 'true';
          
          console.log('='.repeat(80));
          console.log('AUTOMERGE EVALUATION');
          console.log('='.repeat(80));
          console.log(`PR: #${{ github.event.pull_request.number }}`);
          console.log(`Dependency: ${{ steps.dependabot-metadata.outputs.dependency-names }}`);
          console.log(`Version change: ${{ steps.dependabot-metadata.outputs.previous-version }} ‚Üí ${{ steps.dependabot-metadata.outputs.new-version }}`);
          console.log(`Update type: ${updateType}`);
          console.log(`Dependency type: ${dependencyType}`);
          console.log(`Config file exists: ${configExists}`);
          console.log('='.repeat(80));
          
          let shouldMerge = false;
          let matchReason = '';
          
          if (configExists) {
            // Read and parse configuration from JSON passed via environment variable
            try {
              const configJson = process.env.CONFIG_JSON;
              const config = JSON.parse(configJson);
              
              console.log('Configuration rules:', JSON.stringify(config, null, 2));
              console.log('-'.repeat(80));
              
              // Check if there's a rule for package-lock dependency type
              const hasPackageLockRule = config.some(rule => rule.match && rule.match.dependency_type === 'package-lock');
              
              // Check each match rule
              let ruleIndex = 0;
              for (const rule of config) {
                ruleIndex++;
                const match = rule.match;
                if (!match) {
                  console.log(`Rule ${ruleIndex}: Skipped (no match criteria)`);
                  continue;
                }
                
                console.log(`Rule ${ruleIndex}: Checking...`);
                console.log(`  Expected dependency_type: ${match.dependency_type || 'any'}`);
                console.log(`  Expected update_type: ${match.update_type || 'any'}`);
                
                // Check dependency type
                let depTypeMatches = !match.dependency_type || match.dependency_type === dependencyType;
                if (match.dependency_type && !depTypeMatches) {
                  console.log(`  ‚ùå Dependency type mismatch: expected ${match.dependency_type}, got ${dependencyType}`);
                } else if (match.dependency_type) {
                  console.log(`  ‚úÖ Dependency type matches: ${dependencyType}`);
                }
                
                // Check update type (only semver: types are supported)
                // Hierarchical matching: 
                // - semver:patch matches only patch
                // - semver:minor matches patch OR minor
                // - semver:major matches patch OR minor OR major
                let updateTypeMatches = false;
                if (match.update_type) {
                  const matchType = match.update_type;
                  if (matchType.startsWith('semver:')) {
                    const semverType = matchType.replace('semver:', '');
                    
                    // Implement hierarchical matching
                    if (semverType === 'patch') {
                      updateTypeMatches = (updateType === 'patch');
                    } else if (semverType === 'minor') {
                      updateTypeMatches = (updateType === 'patch' || updateType === 'minor');
                    } else if (semverType === 'major') {
                      updateTypeMatches = (updateType === 'patch' || updateType === 'minor' || updateType === 'major');
                    }
                    
                    if (updateTypeMatches) {
                      console.log(`  ‚úÖ Update type matches: ${updateType} is included in ${semverType} rule`);
                    } else {
                      console.log(`  ‚ùå Update type mismatch: ${updateType} is not included in ${semverType} rule`);
                    }
                  } else {
                    console.log(`  ‚ö†Ô∏è  Unsupported update_type format: ${matchType} (only 'semver:' prefixes are supported)`);
                  }
                }
                
                if (depTypeMatches && updateTypeMatches) {
                  shouldMerge = true;
                  matchReason = `Matched rule ${ruleIndex}: dependency_type=${match.dependency_type}, update_type=${match.update_type}`;
                  console.log(`  ‚úÖ RULE MATCHED - Will automerge`);
                  break;
                } else {
                  console.log(`  ‚è≠Ô∏è  Rule did not match`);
                }
              }
              
              // If no rule matched and dependency type is package-lock, apply default rule for package-lock
              if (!shouldMerge && dependencyType === 'package-lock' && !hasPackageLockRule) {
                console.log('-'.repeat(80));
                console.log('No explicit rule for package-lock found in config, applying default rule');
                if (updateType === 'patch' || updateType === 'minor') {
                  shouldMerge = true;
                  matchReason = 'Default rule for package-lock: Minor and patch updates are merged';
                  console.log('‚úÖ ' + matchReason);
                } else {
                  matchReason = 'Default rule for package-lock: Major updates are not merged';
                  console.log('‚ùå ' + matchReason);
                }
              }
              
              if (!shouldMerge && matchReason === '') {
                matchReason = 'No configuration rule matched this update';
              }
            } catch (err) {
              console.error('Error reading config:', err);
              matchReason = `Configuration error: ${err.message}`;
            }
          } else {
            // Default rules (no config file)
            console.log('Using default rules (no config file found)');
            console.log('-'.repeat(80));
            
            if (updateType === 'patch') {
              // Always merge patch updates
              shouldMerge = true;
              matchReason = 'Default rule: Patch updates are always merged';
              console.log('‚úÖ ' + matchReason);
            } else if (updateType === 'minor') {
              // Merge minor updates for devDependencies and package-lock
              if (dependencyType === 'development' || dependencyType === 'package-lock') {
                shouldMerge = true;
                matchReason = `Default rule: Minor updates for ${dependencyType} are merged`;
                console.log('‚úÖ ' + matchReason);
              } else {
                matchReason = 'Default rule: Minor updates for production dependencies are not merged';
                console.log('‚ùå ' + matchReason);
              }
            } else if (updateType === 'major') {
              // Never merge major updates
              matchReason = 'Default rule: Major updates are never merged';
              console.log('‚ùå ' + matchReason);
            } else {
              matchReason = `Unknown update type: ${updateType}`;
              console.log('‚ùå ' + matchReason);
            }
          }
          
          console.log('='.repeat(80));
          console.log(`DECISION: ${shouldMerge ? '‚úÖ WILL AUTOMERGE' : '‚ùå WILL NOT AUTOMERGE'}`);
          console.log(`REASON: ${matchReason}`);
          console.log('='.repeat(80));
          
          core.setOutput('should_merge', shouldMerge.toString());
          core.setOutput('match_reason', matchReason);
          
          return shouldMerge;
    
    - name: Wait for other workflows
      if: |
        steps.should-merge.outputs.should_merge == 'true' &&
        inputs.wait-for-checks == 'true'
      id: wait-for-checks
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const prNumber = ${{ github.event.pull_request.number }};
          const headSha = '${{ github.event.pull_request.head.sha }}';
          
          // Helper function to check if a conclusion is successful
          const isSuccessfulConclusion = (conclusion) => {
            return conclusion === 'success' || conclusion === 'skipped' || conclusion === 'neutral';
          };
          
          // Helper function to get icon for a check
          const getCheckIcon = (check) => {
            if (check.status !== 'completed') return '‚è≥';
            return isSuccessfulConclusion(check.conclusion) ? '‚úÖ' : '‚ùå';
          };
          
          console.log('='.repeat(80));
          console.log('WAITING FOR CI CHECKS');
          console.log('='.repeat(80));
          console.log(`PR: #${prNumber}`);
          console.log(`Commit SHA: ${headSha}`);
          console.log('='.repeat(80));
          
          // Add a 10-second delay to avoid race conditions with checks starting
          console.log('Waiting 10 seconds to avoid race conditions...');
          await new Promise(resolve => setTimeout(resolve, 10000));
          console.log('Initial delay complete, starting to check for workflows');
          
          // Wait for checks to complete
          const maxWaitTime = ${{ inputs.max-wait-time }} * 1000; // Convert to milliseconds
          const pollInterval = 45 * 1000; // 45 seconds
          const startTime = Date.now();
          let otherChecks = []; // Declare outside loop for timeout handler access
          
          while (Date.now() - startTime < maxWaitTime) {
            // Get check runs for the commit
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: headSha,
              per_page: 100
            });
            
            // Filter out this workflow
            otherChecks = checkRuns.check_runs.filter(check => 
              check.name !== 'auto-merge' && 
              check.name !== context.job
            );
            
            console.log(`\nFound ${otherChecks.length} other check(s)`);
            
            if (otherChecks.length === 0) {
              console.log('No other checks found, proceeding with merge');
              console.log('='.repeat(80));
              core.setOutput('checks_passed', 'true');
              return true;
            }
            
            // Check status of all checks
            const pending = otherChecks.filter(check => 
              check.status !== 'completed'
            );
            
            const failed = otherChecks.filter(check => 
              check.status === 'completed' && !isSuccessfulConclusion(check.conclusion)
            );
            
            const successful = otherChecks.filter(check => 
              check.status === 'completed' && isSuccessfulConclusion(check.conclusion)
            );
            
            console.log(`Status: ${successful.length} successful, ${pending.length} pending, ${failed.length} failed`);
            
            if (failed.length > 0) {
              console.log('\n' + '='.repeat(80));
              console.log('‚ùå CHECK FAILURE DETECTED');
              console.log('='.repeat(80));
              console.log('Final results of all checked workflows:');
              otherChecks.forEach(check => {
                const conclusionText = check.status === 'completed' ? check.conclusion : check.status;
                console.log(`  ${getCheckIcon(check)} ${check.name}: ${conclusionText}`);
              });
              console.log('-'.repeat(80));
              console.log('The following checks failed:');
              failed.forEach(check => {
                console.log(`  ‚ùå ${check.name}`);
                console.log(`     Status: ${check.status}`);
                console.log(`     Conclusion: ${check.conclusion}`);
                console.log(`     URL: ${check.html_url}`);
              });
              console.log('='.repeat(80));
              console.log('DECISION: Cannot automerge due to failed checks');
              console.log('='.repeat(80));
              core.setOutput('checks_passed', 'false');
              core.setFailed(`${failed.length} check(s) failed - cannot automerge`);
              return false;
            }
            
            if (pending.length === 0) {
              console.log('\n' + '='.repeat(80));
              console.log('‚úÖ ALL CHECKS PASSED');
              console.log('='.repeat(80));
              console.log('Final results of all checked workflows:');
              otherChecks.forEach(check => {
                console.log(`  ${getCheckIcon(check)} ${check.name}: ${check.conclusion}`);
              });
              console.log('='.repeat(80));
              console.log('DECISION: Proceeding with automerge');
              console.log('='.repeat(80));
              core.setOutput('checks_passed', 'true');
              return true;
            }
            
            // Wait before checking again
            console.log(`\nWaiting for ${pending.length} check(s) to complete...`);
            pending.forEach(check => {
              console.log(`  ‚è≥ ${check.name}: ${check.status}`);
            });
            
            await new Promise(resolve => setTimeout(resolve, pollInterval));
          }
          
          // Timeout
          console.log('\n' + '='.repeat(80));
          console.log('‚è±Ô∏è  TIMEOUT');
          console.log('='.repeat(80));
          console.log('Checks did not complete within the timeout period');
          
          // Log final results of all workflows at timeout
          if (otherChecks && otherChecks.length > 0) {
            console.log('-'.repeat(80));
            console.log('Final results of all checked workflows at timeout:');
            otherChecks.forEach(check => {
              const conclusionText = check.status === 'completed' ? check.conclusion : check.status;
              console.log(`  ${getCheckIcon(check)} ${check.name}: ${conclusionText}`);
            });
          }
          
          console.log('='.repeat(80));
          core.setFailed('Timeout waiting for checks to complete');
          core.setOutput('checks_passed', 'false');
          return false;
    
    - name: Set checks passed when not waiting
      if: |
        steps.should-merge.outputs.should_merge == 'true' &&
        inputs.wait-for-checks != 'true'
      id: skip-checks
      shell: bash
      run: |
        echo "checks_passed=true" >> $GITHUB_OUTPUT
    
    - name: Merge PR
      if: |
        steps.should-merge.outputs.should_merge == 'true' &&
        (steps.wait-for-checks.outputs.checks_passed == 'true' || steps.skip-checks.outputs.checks_passed == 'true')
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const prNumber = ${{ github.event.pull_request.number }};
          const mergeMethod = '${{ inputs.merge-method }}';
          const matchReason = '${{ steps.should-merge.outputs.match_reason }}';
          
          console.log('='.repeat(80));
          console.log('MERGING PR');
          console.log('='.repeat(80));
          console.log(`PR: #${prNumber}`);
          console.log(`Merge method: ${mergeMethod}`);
          console.log('='.repeat(80));
          
          // Helper function to fetch PR metadata and files for comments
          const fetchPRMetadata = async () => {
            // Fetch list of files modified by the PR
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            const filesList = files.length > 0 ? files.map(f => `- ${f.filename}`).join('\n') : '- (no files modified)';
            
            // Prepare dependabot metadata
            const dependencyNames = '${{ steps.dependabot-metadata.outputs.dependency-names }}';
            const previousVersion = '${{ steps.dependabot-metadata.outputs.previous-version }}';
            const newVersion = '${{ steps.dependabot-metadata.outputs.new-version }}';
            const updateType = '${{ steps.metadata.outputs.update_type }}';
            const dependencyType = '${{ steps.metadata.outputs.dependency_type }}';
            
            return {
              filesList,
              dependencyNames,
              previousVersion,
              newVersion,
              updateType,
              dependencyType
            };
          };
          
          // Helper function to format metadata section for comments
          const formatMetadataSection = (metadata) => {
            return [
              '\n\n**Dependabot Information:**\n',
              `- **Package name(s):** ${metadata.dependencyNames}\n`,
              `- **Update type:** ${metadata.updateType}\n`,
              `- **Dependency type:** ${metadata.dependencyType}\n`,
              `- **Previous version:** ${metadata.previousVersion}\n`,
              `- **New version:** ${metadata.newVersion}\n\n`,
              '**Modified Files:**\n',
              `${metadata.filesList}`
            ].join('');
          };
          
          // Fetch current PR state to check if rebase is in progress
          let pr = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prNumber,
          });
          pr = pr.data;
          
          console.log(`PR mergeable_state: ${pr.mergeable_state}`);
          console.log(`PR mergeable: ${pr.mergeable}`);
          
          // Wait for up to 60 minutes if mergeable_state is 'unknown' (rebase in progress)
          if (pr.mergeable_state === 'unknown') {
            console.log('‚è∏Ô∏è  PR mergeable_state is unknown - waiting for rebase or mergeability computation to complete');
            console.log('Will poll every minute for up to 60 minutes');
            console.log('='.repeat(80));
            
            const maxWaitTime = 60 * 60 * 1000; // 60 minutes in milliseconds
            const pollInterval = 60 * 1000; // 1 minute in milliseconds
            const startTime = Date.now();
            let waitSuccess = false;
            
            while (Date.now() - startTime < maxWaitTime) {
              await new Promise(resolve => setTimeout(resolve, pollInterval));
              
              const elapsed = Math.floor((Date.now() - startTime) / 1000 / 60);
              console.log(`\n‚è±Ô∏è  Elapsed time: ${elapsed} minute(s)`);
              
              // Fetch updated PR state
              const prUpdate = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
              });
              pr = prUpdate.data;
              
              console.log(`PR mergeable_state: ${pr.mergeable_state}`);
              console.log(`PR mergeable: ${pr.mergeable}`);
              
              // Check if mergeable_state has changed
              if (pr.mergeable_state !== 'unknown') {
                console.log('‚úÖ PR mergeable_state is no longer unknown');
                waitSuccess = true;
                break;
              }
              
              // Check if PR is no longer mergeable
              if (pr.mergeable === false) {
                console.log('‚ùå PR is no longer mergeable');
                const metadata = await fetchPRMetadata();
                const comment = `‚ùå **Automerge Failed**\n\nThe PR became unmergeable during the waiting period.\n\n**Reason:** ${matchReason}\n**Status:** mergeable_state=${pr.mergeable_state}, mergeable=${pr.mergeable}${formatMetadataSection(metadata)}`;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: comment,
                });
                console.log('='.repeat(80));
                core.setFailed('PR became unmergeable during waiting period');
                return;
              }
              
              console.log('Still waiting...');
            }
            
            // If still unknown after 60 minutes, request recreation
            if (!waitSuccess) {
              console.log('\n‚è±Ô∏è  Timeout: PR mergeable_state still unknown after 60 minutes');
              console.log('Adding status comment and Dependabot recreation command');
              
              // Post status information as first comment
              const metadata = await fetchPRMetadata();
              const statusComment = `‚è±Ô∏è **Automerge Timeout**\n\nThe PR mergeable_state remained unknown after 60 minutes of waiting.${formatMetadataSection(metadata)}`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: statusComment,
              });
              
              // Post @dependabot recreate as separate comment
              const recreateComment = `@dependabot recreate`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: recreateComment,
              });
              
              console.log('‚úÖ Successfully added status and recreation comments');
              console.log('='.repeat(80));
              core.setFailed('PR mergeable_state remained unknown after 60 minutes');
              return;
            }
            
            console.log('='.repeat(80));
          }
          
          // Log final mergeable state before attempting merge
          console.log('\nüìä Final PR Status:');
          console.log(`   mergeable_state: ${pr.mergeable_state}`);
          console.log(`   mergeable: ${pr.mergeable}`);
          console.log('='.repeat(80));
          
          // Verify that PR is mergeable and not in dirty or unknown state
          // Note: This is a safety check. While 'unknown' is handled by the timeout logic above,
          // this ensures we catch any edge cases where the state might still be unknown or dirty
          if (pr.mergeable !== true || pr.mergeable_state === 'dirty' || pr.mergeable_state === 'unknown') {
            console.log('\n‚ùå PR is not in a mergeable state');
            console.log(`   mergeable: ${pr.mergeable}`);
            console.log(`   mergeable_state: ${pr.mergeable_state}`);
            console.log('Adding status comment and Dependabot recreation command');
            
            // Post status information as first comment
            const metadata = await fetchPRMetadata();
            const statusComment = `‚ö†Ô∏è **Automerge Skipped**\n\nMerging is skipped because the PR is in a dirty or unknown state.\n\n**Status:** mergeable=${pr.mergeable}, mergeable_state=${pr.mergeable_state}${formatMetadataSection(metadata)}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: statusComment,
            });
            
            // Post @dependabot recreate as separate comment
            const recreateComment = `@dependabot recreate`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: recreateComment,
            });
            
            console.log('‚úÖ Successfully added status and recreation comments');
            console.log('='.repeat(80));
            core.setFailed(`PR is not mergeable: mergeable=${pr.mergeable}, mergeable_state=${pr.mergeable_state}`);
            return;
          }
          
          try {
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: mergeMethod,
            });
            
            console.log(`‚úÖ Successfully merged PR #${prNumber}`);
            console.log('='.repeat(80));
            
            // Fetch PR metadata and files
            const metadata = await fetchPRMetadata();
            
            // Add success comment to PR with enhanced information
            const comment = [
              '‚úÖ **Automerged**\n',
              `**Reason:** ${matchReason}\n`,
              `**Merge method:** ${mergeMethod}`,
              formatMetadataSection(metadata)
            ].join('');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment,
            });
          } catch (error) {
            console.log(`‚ùå Failed to merge PR #${prNumber}`);
            console.log(`Error: ${error.message}`);
            console.log('='.repeat(80));
            
            // Add failure comment to PR
            const metadata = await fetchPRMetadata();
            const comment = `‚ùå **Automerge Failed**\n\n**Reason for attempting merge:** ${matchReason}\n**Error:** ${error.message}\n**Status:** mergeable_state=${pr.mergeable_state}, mergeable=${pr.mergeable}${formatMetadataSection(metadata)}`;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment,
            });
            
            core.setFailed(error.message);
          }
    
    - name: Comment on PR when not automerging
      # This step runs when: PR doesn't match automerge rules OR CI checks failed/timed out
      if: |
        steps.should-merge.outputs.should_merge != 'true' ||
        (steps.wait-for-checks.outputs.checks_passed != 'true' && steps.skip-checks.outputs.checks_passed != 'true')
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const prNumber = ${{ github.event.pull_request.number }};
          const shouldMerge = '${{ steps.should-merge.outputs.should_merge }}' === 'true';
          const matchReason = '${{ steps.should-merge.outputs.match_reason }}';
          const checksPassedWait = '${{ steps.wait-for-checks.outputs.checks_passed }}';
          const checksPassedSkip = '${{ steps.skip-checks.outputs.checks_passed }}';
          
          // Fetch PR metadata and files
          const { data: files } = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prNumber,
          });
          
          const filesList = files.length > 0 ? files.map(f => `- ${f.filename}`).join('\n') : '- (no files modified)';
          
          // Prepare dependabot metadata
          const dependencyNames = '${{ steps.dependabot-metadata.outputs.dependency-names }}';
          const previousVersion = '${{ steps.dependabot-metadata.outputs.previous-version }}';
          const newVersion = '${{ steps.dependabot-metadata.outputs.new-version }}';
          const updateType = '${{ steps.metadata.outputs.update_type }}';
          const dependencyType = '${{ steps.metadata.outputs.dependency_type }}';
          
          const metadataSection = [
            '\n\n**Dependabot Information:**\n',
            `- **Package name(s):** ${dependencyNames}\n`,
            `- **Update type:** ${updateType}\n`,
            `- **Dependency type:** ${dependencyType}\n`,
            `- **Previous version:** ${previousVersion}\n`,
            `- **New version:** ${newVersion}\n\n`,
            '**Modified Files:**\n',
            `${filesList}`
          ].join('');
          
          let reason = '';
          
          if (!shouldMerge) {
            reason = `The PR does not match any automerge rules.\n\n**Details:** ${matchReason}`;
          } else {
            // If shouldMerge is true but we're in this step, checks must have failed
            // (the step condition ensures we only run when checks didn't pass)
            reason = `CI checks failed or timed out.`;
          }
          
          const comment = `‚ùå **Not Automerged**\n\n${reason}${metadataSection}`;
          
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prNumber,
            body: comment,
          });
          
          console.log('Added comment to PR explaining why it was not automerged');
